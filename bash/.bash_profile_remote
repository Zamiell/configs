# shellcheck shell=bash

# Compatibility notes:
# - `mkdir` does not support `--parents` on macOS, so we use "-p" instead.
# - `sed` does not support `--quiet` on macOS, so we use "-n" instead.

# ----------------
# Helper functions
# ----------------

add_logix_cert_to_requests_ca_bundle() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${REQUESTS_CA_BUNDLE:-}" ]]; then
    return
  fi

  if [[ ! -s "$REQUESTS_CA_BUNDLE" ]]; then
    echo "Error: The \"REQUESTS_CA_BUNDLE\" environment variable is set to \"$REQUESTS_CA_BUNDLE\", but this file does not exist or is 0 bytes." >&2
    return 1
  fi

  local certificate_name="BEDROOTCA001"
  if ! grep --quiet "$certificate_name" "$REQUESTS_CA_BUNDLE"; then
    echo "Error: The \"REQUESTS_CA_BUNDLE\" environment variable is set to \"$REQUESTS_CA_BUNDLE\", but this file does not have the \"$certificate_name\" certificate in it." >&2
    local file_path="$REQUESTS_CA_BUNDLE"
    if is_git_bash; then
      file_path=$(cygpath --windows "$file_path")
    fi

    echo >&2
    echo "Run this command to fix it:" >&2
    echo >&2
    echo "{ echo; echo \"# $certificate_name\"; curl --silent --fail --show-error --location \"https://raw.githubusercontent.com/Zamiell/configs/refs/heads/main/certs/$certificate_name.crt\"; } >> \"$REQUESTS_CA_BUNDLE\"" >&2
    return 1
  fi
)

# If we use a subshell, the changes to PATH would be lost.
append_path() {
  if [[ -z "${1:-}" ]]; then
    echo "Error: The path is required. Usage: ${FUNCNAME[0]} <path>" >&2
    return 1
  fi
  local directory="$1"

  # Check if the directory exists and is not already in the PATH.
  if [[ -d "$directory" ]] && [[ ":$PATH:" != *":$directory:"* ]]; then
    export PATH="$PATH:$directory"
  fi
}

assert_git_repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi
)

assert_feature_branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi
)

assert_main_branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ "$branch_name" != "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on the \"$main_branch_name\" branch and you are currently on the \"$branch_name\" branch." >&2
    return 1
  fi
)

get_first_branch_commit_description() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  local merge_base
  merge_base=$(get_merge_base)

  local first_commit_hash
  first_commit_hash=$(git rev-list --reverse "$merge_base..$branch_name" | head -n 1)
  if [[ -z "$first_commit_hash" ]]; then
    echo "Error: There are no commits on this branch when compared to the \"$main_branch_name\" branch." >&2
    return 1
  fi

  printf "%s" "$(git show --no-patch --format="%B" "$first_commit_hash")"
)

# This will return a descriptive commit message based on the currently staged files.
get_llm_commit_message() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff --cached)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no staged changes in the current Git repository." >&2
    return 1
  fi

  get_llm_output_git_diff "$git_diff" "commit message"
)

# This will return a pull request description based on differences between the current branch and
# the main branch. (Similar to a commit message, the title will be on the first line and the
# description will be on the second line, if any.)
get_llm_pull_request_text() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    # If the user does not have an API key, return a generic commit message.
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff "$main_branch_name"...HEAD)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no changes between this branch and the \"$main_branch_name\" branch." >&2
    return 1
  fi

  get_llm_output_git_diff "$git_diff" "pull request description"
)

get_llm_output_git_diff() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The git diff is required. Usage: ${FUNCNAME[0]} <git_diff> <noun>" >&2
    return 1
  fi
  local git_diff="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The noun is required. Usage: ${FUNCNAME[0]} <git_diff> <noun>" >&2
    return 1
  fi
  local noun="$2"

  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required to use the automated commit message feature. If you are on Windows, you can install it with: winget install --exact --id jqlang.jq" >&2
    return 1
  fi

  local system_prompt="You are an expert git commit message generator. You will be given a git diff. Your response must be only the commit message; do not include any preamble, explanation, or markdown. Be concise and descriptive. The commit message is allowed to be more than one line, but only if the changes are complicated. Follow the 50/72 rule. Follow conventional commit standards (e.g. \"feat: add new feature\", \"fix: correct bug\", \"chore: update build\"). Pay particular attention to removed lines, since if a block of code is moved from one place to another, the commit message should not say \"add\", it should say \"move\". If the file being modified is in the \"3_Applications/kubernetes\" directory, then add a commit message scope like \"feat(kubernetes): add variable\". Additionally, the subdirectories of \"3_Applications/containers\" should be scoped to their directory name in the same way. For example, modifying a file in the \"3_Applications/containers/logix-ci-cd-tasks\" directory should result in a commit message like \"feat(logix-ci-cd-tasks): add variable\"."

  local llm_output
  llm_output=$(get_llm_output "$system_prompt" "$git_diff")

  echo -e "$llm_output\n\n(This $noun was automatically generated by an LLM.)"
)

get_llm_output() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The system prompt is required. Usage: ${FUNCNAME[0]} <system_prompt> <prompt>" >&2
    return 1
  fi
  local system_prompt="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The prompt is required. Usage: ${FUNCNAME[0]} <system_prompt> <prompt>" >&2
    return 1
  fi
  local prompt="$2"

  # Because there can be a huge amount of data in the git diff, we need to create the API response
  # all in one command. Otherwise, we get errors like "Argument list too long".
  # 1. printf pipes the prompt into jq.
  # 2. jq pipes the JSON payload into curl.
  # 3. curl reads from stdin using "--data @-".
  # Additionally, we have to use the "--ssl-no-revoke" flag with Google URLs when using curl inside
  # Git Bash for Windows, since the LogixHealth Palo Alto blocks the revocation check for some
  # reason.
  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${GEMINI_API_KEY}"
  local api_response
  api_response=$(
    printf "%s" "$prompt" | jq \
      --raw-input \
      --slurp \
      --arg system_prompt_str "$system_prompt" \
      '{
      "systemInstruction": {
        "parts": [{ "text": $system_prompt_str }]
      },
      "contents": [
        { "parts": [{ "text": . }] }
      ]
     }' | curl \
      --silent \
      --fail \
      --show-error \
      --request POST \
      --header "content-type: application/json" \
      --data @- \
      --ssl-no-revoke \
      "$api_url" || {
      local err="$?"
      echo "curl failed on URL: $api_url" >&2
      return "$err"
    }
  )

  if ! echo "$api_response" | jq --exit-status '.candidates' > /dev/null; then
    echo "Error: The LLM API returned an error:" >&2
    echo "$api_response" >&2
    return 1
  fi

  local llm_output
  llm_output=$(echo "$api_response" | jq --raw-output '.candidates[0].content.parts[0].text | select(. != null)')

  if [[ -z "$llm_output" ]]; then
    echo "Error: LLM generation failed." >&2
    return 1
  fi

  echo "$llm_output"
)

get_main_branch_name() (
  set -euo pipefail # Exit on errors and undefined variables.

  if git show-ref --verify --quiet refs/heads/main; then
    echo "main"
  elif git show-ref --verify --quiet refs/heads/master; then
    echo "master"
  else
    echo "Error: There was not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi
)

get_merge_base() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  local merge_base
  merge_base=$(git merge-base "$main_branch_name" "$branch_name")
  if [[ -z "$merge_base" ]]; then
    echo "Error: Could not find a common ancestor with the \"$main_branch_name\" branch." >&2
    return 1
  fi

  echo "$merge_base"
)

get_num_commits_on_branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local branch_name
  branch_name=$(git branch --show-current)

  local merge_base
  merge_base=$(get_merge_base)

  git rev-list --count "$merge_base..$branch_name"
)

is_git_bash() (
  set -euo pipefail # Exit on errors and undefined variables.

  local kernel_name
  kernel_name=$(uname -s) # The "--kernel-name" flag is not supported on MacOS.
  [[ "$kernel_name" =~ ^MINGW || "$kernel_name" =~ ^MSYS_NT ]]
)

is_github_repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    return 1 # False
  fi

  # e.g. "git@github.com:alice/my-repo.git" or "https://github.com/alice/my-repo.git"
  local remote_url
  remote_url=$(git remote get-url origin)

  if echo "$remote_url" | grep --quiet "github.com"; then
    return # True
  fi

  return 1 # False
)

# When we "cd" to a Git repository, we want to show the branches. Otherwise, can we show the list of
# files in the directory.
print_files_and_branches() (
  set -euo pipefail # Exit on errors and undefined variables.

  # We use the same flags as the "ll" alias. (We cannot use the alias directly as the subshell does
  # not have access to it.
  ls -a -h -l -F --color=auto

  # On Git Gash, the "git rev-parse" command will show a directory in the format of:
  # D:/Repositories/configs
  # Thus, we have to made some modifications
  local current_dir
  current_dir=$(pwd)
  local git_top_dir
  git_top_dir=$(git rev-parse --show-toplevel 2> /dev/null)

  if command -v cygpath &> /dev/null; then
    # "/c/Repositories/foo" --> "C:\Repositories\configs"
    current_dir=$(cygpath --windows "$current_dir")
    current_dir=$(to_lowercase "$current_dir")

    # "C:/Repositories/foo" --> "C:\Repositories\foo"
    git_top_dir=$(cygpath --windows "$git_top_dir")
    git_top_dir=$(to_lowercase "$git_top_dir")
  fi

  if [[ "$current_dir" = "$git_top_dir" ]]; then
    echo
    gbl
  fi
)

remove_leading_and_trailing_whitespace() {
  sed --expression '/[^[:space:]]/,$!d' --expression 's/^[[:space:]]*//' --expression 's/[[:space:]]*$//'
}

to_lowercase() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ $# -eq 0 ]]; then
    echo "Error: At least one string argument is required. Usage: ${FUNCNAME[0]} <string> ..." >&2
    return 1
  fi

  # https://stackoverflow.com/questions/41166026/what-does-2-commas-after-variable-name-mean-in-bash
  echo "${@,,}"
)

# ---------------------
# Environment Variables
# ---------------------

# Load secret environment variables that cannot be committed to Git.
if [[ -s "$HOME/.env" ]]; then
  # shellcheck source=/dev/null
  source "$HOME/.env"
fi

# Fix self-signed certs for LogixHealth.
if [[ -s "/usr/local/share/ca-certificates/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/usr/local/share/ca-certificates/BEDROOTCA001.crt"
elif [[ -s "/c/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/tls/BEDROOTCA001.crt"
elif [[ -s "/c/_IT/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/_IT/tls/BEDROOTCA001.crt"
fi
if [[ -n "${COMPANY_CERT_PATH-}" ]]; then
  export NODE_EXTRA_CA_CERTS="$COMPANY_CERT_PATH"
  export CURL_CA_BUNDLE="$COMPANY_CERT_PATH"
fi
if [[ -s "/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -s "/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -s "/opt/az/lib/python3.13/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/opt/az/lib/python3.13/site-packages/certifi/cacert.pem"
fi
add_logix_cert_to_requests_ca_bundle

# Get the username in an operating system agnostic way.
if [[ -n "$USER" ]]; then
  export OS_USERNAME="$USER"
elif [[ -n "$USERNAME" ]]; then
  export OS_USERNAME="$USERNAME"
else
  echo "Failed to derive the operating system username." >&2
fi

# ----
# Path
# ----

# Add browsers to the path, which is necessary for the GitHub CLI.
if ! command -v chrome &> /dev/null && [[ -s "/c/Program Files/Google/Chrome/Application/chrome.exe" ]]; then
  export PATH="$PATH:/c/Program Files/Google/Chrome/Application"
fi
if ! command -v chrome &> /dev/null && command -v google-chrome &> /dev/null; then
  alias chrome="google-chrome"
fi
if ! command -v msedge &> /dev/null && [[ -s "/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" ]]; then
  export PATH="$PATH:/c/Program Files (x86)/Microsoft/Edge/Application"
fi
if ! command -v msedge &> /dev/null && command -v microsoft-edge &> /dev/null; then
  alias msedge="microsoft-edge"
fi

# bun
# https://bun.com/
append_path "$HOME/.bun"

# Claude Code
# https://www.claude.com/product/claude-code
append_path "$HOME/.local/bin"

# fnm
# https://github.com/Schniz/fnm
append_path "$HOME/AppData/Local/Microsoft/WinGet/Packages/Schniz.fnm_Microsoft.Winget.Source_8wekyb3d8bbwe"

if command -v fnm &> /dev/null && ! command -v node &> /dev/null; then
  eval "$(fnm env --shell bash)"
fi

# ----------------------
# Miscellaneous Commands
# ----------------------

# Ask an LLM a question from the terminal.
ai() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ $# -eq 0 ]]; then
    echo "Error: The prompt is required. Usage: ${FUNCNAME[0]} <prompt>" >&2
    return 1
  fi
  local prompt="$*"

  local system_prompt="You are being asked a question inside of a terminal. Be fairly brief in your response. For example, if you are being asked what the command is for something, format your response as just the command and a 1-2 sentence description."

  get_llm_output "$system_prompt" "$prompt"
)

# Only create this alias if the shell is interactive.
if [[ $- == *i* ]]; then
  # We have to use braces instead of parenthesis here.
  cd() {
    builtin cd "$@" && print_files_and_branches
  }
fi

# It is annoying that Claude Code requires permission to edit files on every invocation.
alias claude="claude --permission-mode acceptEdits"

# "csf" is short for "bunx cspell-check-unused-words --fix".
csf() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  bunx cspell-check-unused-words --fix

  if [[ -n "$(git status --porcelain)" ]]; then
    gc "chore: removing unused words from the CSpell configuration file"
  fi
)

# Alias "explorer" to "open" on macOS and "xdg-open" on Linux.
explorer() (
  set -euo pipefail # Exit on errors and undefined variables.

  if command -v explorer &> /dev/null; then
    # We must use "command" to invoke "explorer" to prevent an infinite loop.
    command explorer "$@"
  else
    if [[ "$(uname)" == "Darwin" ]]; then
      open "$@"
    else
      xdg-open "$@"
    fi
  fi
)

# A better "ll" alias that shows human-readable file sizes.
# (macOS does not support any of the long-form flags, so we use the short ones instead.)
# - "-a" is short for "--all", which shows hidden files.
# - "-h" is short for "--human-readable", which converts bytes to kilobytes and so on.
# - "-F" is short for "--classify", which displays extra characters to signify the file type.
# - "--color=auto" makes Ubuntu have the same colors that Git Bash for Windows does.
alias ll="ls -a -h -l -F --color=auto"

# "n" is short for "nuke".
alias n="npx complete-cli@latest nuke"

# "o" is short for "open", to open a URL in a browser.
o() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: URL is required. Usage: ${FUNCNAME[0]} <url>" >&2
    return 1
  fi
  local url="$1"

  if [[ "$url" == *"logixhealth"* ]] && command -v msedge &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    msedge "$url" > /dev/null
    return
  fi

  if command -v chrome &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    chrome "$url" > /dev/null
    return
  fi

  # macOS and Linux have the "open" command:
  # https://ss64.com/mac/open.html
  if command -v open &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    open "$url" > /dev/null
    return
  fi

  echo "Git commit URL is at:"
  echo "$url"
)

# "r" is short for switching to the repositories directory.
if [[ -d "/c/Users/$OS_USERNAME/Repositories" ]]; then # Generic Windows
  REPOSITORIES_DIR="/c/Users/$OS_USERNAME/Repositories"
elif [[ -d "/Users/$OS_USERNAME/repositories" ]]; then # Generic MacOS (1/2)
  REPOSITORIES_DIR="/Users/$OS_USERNAME/repositories"
elif [[ -d "/Users/$OS_USERNAME/Repositories" ]]; then # Generic MacOS (2/2)
  REPOSITORIES_DIR="/Users/$OS_USERNAME/Repositories"
elif [[ -d "/home/$OS_USERNAME/repositories" ]]; then # Generic Linux (1/2)
  REPOSITORIES_DIR="/home/$OS_USERNAME/repositories"
elif [[ -d "/home/$OS_USERNAME/Repositories" ]]; then # Generic Linux (2/2)
  REPOSITORIES_DIR="/home/$OS_USERNAME/Repositories"
elif [[ -d "/c/Repositories" ]]; then # Windows C drive
  REPOSITORIES_DIR="/c/Repositories"
elif [[ -d "/d/Repositories" ]]; then # Windows D drive
  REPOSITORIES_DIR="/d/Repositories"
fi
if [[ -n "$REPOSITORIES_DIR" ]]; then
  export REPOSITORIES_DIR
  alias r='builtin cd $REPOSITORIES_DIR'

  # By default, it is useful for shells to open in the repositories directory instead of the home
  # directory. (But only do this if the shell is interactive and we are actually starting in the
  # home directory.)
  if [[ $- == *i* ]] && [[ "$(pwd)" == "$HOME" ]]; then
    builtin cd "$REPOSITORIES_DIR"
  fi
fi

# Establishes a connection to the LogixHealth VPN in the background. (This is intended to be used on
# Linux devices.)
vpn() (
  set -euo pipefail # Exit on errors and undefined variables.

  MICROSOFT_EDGE_PATH="/opt/microsoft/msedge/msedge"
  if [[ ! -s "$MICROSOFT_EDGE_PATH" ]]; then
    echo "Error: Microsoft Edge must be installed at: $MICROSOFT_EDGE_PATH" >&2
    return 1
  fi

  sudo killall gpclient
  sudo nohup gpclient connect lhvpn.logixhealth.com --browser "$MICROSOFT_EDGE_PATH" &
)

# ----------------
# kubectl Commands
# ----------------

alias k="kubectl"
alias kdd="kubectl describe deployment"
alias kdp="kubectl describe pod"
alias kds="kubectl describe service"
alias kgd="kubectl get deployment"
alias kgp="kubectl get pod"

# ------------
# npm Commands
# ------------

get_package_manager() (
  set -euo pipefail # Exit on errors and undefined variables.

  local current_dir
  current_dir="$(pwd)"

  # Search upward through directories, looking for package lock files.
  # (We deliberately use "-f" over "-s" to be as conservative as possible.)
  while [ "$current_dir" != "/" ]; do
    if [[ -f "$current_dir/package-lock.json" ]]; then
      echo "npm"
      return
    fi

    if [[ -f "$current_dir/yarn.lock" ]]; then
      echo "yarn"
      return
    fi

    if [[ -f "$current_dir/pnpm-lock.yaml" ]]; then
      echo "pnpm"
      return
    fi

    if [[ -f "$current_dir/bun.lock" ]]; then
      echo "bun"
      return
    fi

    current_dir="$(dirname "$current_dir")"
  done

  echo "Error: Not able to determine the package manager for the current project." >&2
  return 1
)

run_package_script() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1-}" ]]; then
    echo "Error: Script name is required." >&2
    return 1
  fi

  local package_manager
  package_manager="$(get_package_manager)"
  "$package_manager" run "$@"
)

alias b="run_package_script build"
alias d="run_package_script dev"
alias l="run_package_script lint"
alias la="run_package_script lint-all"
alias p="run_package_script publish"
alias s="run_package_script start"
alias t="run_package_script test"
alias tpr="run_package_script test-pr"
alias u="run_package_script update || bunx complete-cli@latest update"

alias cu="bunx cspell-check-unused-words --fix"

# "ua" is short for "update all", which will recursively update all "package.json" files from the
# current working directory.
ua() (
  set -euo pipefail # Exit on errors and undefined variables.

  local package_json_files
  package_json_files="$(find . -name node_modules -prune -o -name package.json -print)"

  while IFS= read -r package_json; do
    if [[ -n "$package_json" ]]; then
      local package_json_dir
      package_json_dir="$(dirname "$package_json")"
      echo
      echo "Updating packages in: $package_json_dir"
      echo
      (cd "$package_json_dir" && u)
    fi
  done <<< "$package_json_files"
)

# ----------
# Git Config
# ----------

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreautocrlf
# Default value: input
# Explicitly setting it to false prevents Git from changing line endings at any point, which can
# prevent issues when Windows users collaborate with MacOS/Linus users.
git config --global core.autocrlf false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreignoreCase
# Default value: false (on Linux machines) or true (on Windows machines)
# Explicitly setting it to false can prevent problems with interop between Linux & Windows.
git config --global core.ignorecase false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-diffcolorMoved
# Default value: false
# Setting zebra can make git diffs easier to read by having a different color for moved lines.
git config --global diff.colorMoved zebra

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchprune
# Default value: false
# Automatically remove any remote-tracking references that no longer exist on the remote.
git config --global fetch.prune true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchpruneTags
# Default value: false
# Automatically remove any tags that no longer exist on the remote.
git config --global fetch.pruneTags true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pullrebase
# Default value: false
# Setting this prevents spurious merge commits.
git config --global pull.rebase true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pushautoSetupRemote
# Default value: false
# Setting this automates having "git pull" and "git push" work properly after setting up a new
# branch.
git config --global push.autoSetupRemote true

# ------------
# Git Commands
# ------------

# "ga" is short for "git add".
alias ga="git add"

# "gaa" is short for "git add --all".
alias gaa="git add --all"

# - "gb" is short for creating a new git branch, which is a common coding task.
# - If the remote repository is not GitHub, this will make the branch according to the LogixHealth
#   branch naming convention.
# - Doing a push is important after creating a new branch because it prevents subsequent `git pull`
#   calls from failing.
gb() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local description
  if [[ -z "${1:-}" ]]; then
    description="misc"
  else
    description="$1"
  fi

  local application_name
  if [[ -z "${2:-}" ]]; then
    application_name="misc"
  else
    application_name="$2"
  fi

  local new_branch_name
  if is_github_repository; then
    new_branch_name="$description"
  else
    new_branch_name="feature/$application_name/$OS_USERNAME/$description"
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before creating a new git branch"
  fi

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream &> /dev/null; then
    gh-sync
  else
    git pull --rebase
  fi

  git switch --create "$new_branch_name"
  git push

  if [[ $(git stash list | wc -l) -gt 0 ]]; then
    echo "A previous git stash exists. Applying it to this new branch."
    git stash pop
  fi

  echo
  gbl
)

# "gb_" is the same thing as "gb", but if the remote repository is not GitHub, it will omit the
# branch naming logic.
gb_() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local new_branch_name
  if [[ -z "${1:-}" ]]; then
    new_branch_name="misc"
  else
    new_branch_name="$1"
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before creating a new git branch"
  fi

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream &> /dev/null; then
    gh-sync
  else
    git pull --rebase
  fi

  git switch --create "$new_branch_name"
  git push

  if [[ $(git stash list | wc -l) -gt 0 ]]; then
    echo "A previous git stash exists. Applying it to this new branch."
    git stash pop
  fi

  echo
  gbl
)

# "gbc" is short for "git branch clean", which will remove all local branches that do not exist on
# the remote repository.
# https://stackoverflow.com/questions/7726949/remove-tracking-branches-no-longer-on-remote
gbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  local skip_fetch=false
  for arg in "$@"; do
    if [[ "$arg" == "--skip-fetch" ]]; then
      skip_fetch=true
    fi
  done

  assert_git_repository

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if [[ "$skip_fetch" == false ]]; then
    git fetch --prune --quiet
  fi

  git branch -vv | awk "/: gone]/{print \$1}" | xargs --no-run-if-empty git branch --delete --force

  # Additionally, we want to delete branches from merged pull requests.
  if git remote get-url upstream &> /dev/null; then
    gh-clean
  fi

  echo
  gbl
)

# "gbd" is short for "git branch delete", which will delete the branch both locally and remotely.
gbd() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local branch_arg=""
  local only_local="false"

  for arg in "$@"; do
    if [[ "$arg" == "--only-local" ]]; then
      only_local="true"
    else
      branch_arg="$arg"
    fi
  done

  if [[ -z "$branch_arg" ]]; then
    echo "Error: Branch name or number is required. Usage: ${FUNCNAME[0]} <branch-name-or-number> [--only-local]" >&2
    return 1
  fi

  local branch_name
  if [[ "$branch_arg" =~ ^[0-9]+$ ]]; then
    local branch_number="$branch_arg"
    local local_branches
    local_branches=$(git branch --format="%(refname:short)" | sort)
    branch_name=$(echo "$local_branches" | sed -n "${branch_number}p")

    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    branch_name="$branch_arg"
  fi

  if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "master" ]]; then
    echo "Error: You cannot use this command to delete the \"$branch_name\" branch. Are you sure you want to delete that?" >&2
    return 1
  fi

  local current_branch_name
  current_branch_name=$(git branch --show-current)
  if [[ "$branch_name" == "$current_branch_name" ]]; then
    echo "Error: You are deleting branch \"$branch_name\", but that is the branch that you are currently on. Switch to another branch first." >&2
    return 1
  fi

  # Delete the branch locally.
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git branch --delete --force "$branch_name"
    echo "Deleted branch \"$branch_name\" locally."
  else
    echo "Warning: Branch \"$branch_name\" does not exist locally."
  fi

  # Delete the branch remotely.
  if [[ "$only_local" == "false" ]]; then
    if git ls-remote --heads origin "$branch_name" | grep --quiet .; then
      git push origin ":$branch_name"
      echo "Deleted branch \"$branch_name\" remotely."
    else
      echo "Warning: Branch \"$branch_name\" does not exist on remote origin."
    fi
  fi

  echo
  gbl
)

# "gbdl" is short for "git branch delete local", which will delete the branch locally (and not
# remotely).
gbdl() (
  gbd "$1" --only-local
)

# "gbl" is short for "git branch list". ("gb" is already taken by another command.)
gbl() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local local_branches
  local_branches=$(git branch --format="%(refname:short)" | sort)
  local current_branch
  current_branch=$(git branch --show-current)

  local GREEN_CODE='\033[32m'
  local RESET_CODE='\033[0m'

  local total_lines
  total_lines=$(echo "$local_branches" | wc -l | tr -d '[:space:]')
  local width=${#total_lines}

  echo "Current git branches:"

  local count=1
  while IFS= read -r branch; do
    if [[ "$branch" == "$current_branch" ]]; then
      printf "${GREEN_CODE}* %*d - %s${RESET_CODE}\n" "$width" "$count" "$branch"
    else
      printf "  %*d - %s\n" "$width" "$count" "$branch"
    fi

    ((count++))
  done <<< "$local_branches"
)

# "gblr" is short for "git branch list remote".
gblr() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  git fetch --prune --quiet

  local remote_branches
  remote_branches=$(git branch --format="%(refname:short)" --remotes | grep --invert-match --line-regexp "origin" | grep --invert-match "^origin/" | sort)

  echo "Remote git branches:"

  local count=1
  while IFS= read -r branch; do
    echo "  ${count} - ${branch}"
    ((count++))
  done <<< "$remote_branches"
)

# "gbr" is short for "git branch rename", which will rename the application and/or description
# portion of a LogixHealth branch name.
gbr() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: Application name is required. Usage: ${FUNCNAME[0]} <application-name> [description]" >&2
    return 1
  fi
  local new_app_name="$1"

  local old_branch_name
  old_branch_name=$(git branch --show-current) # e.g. "feature/misc/alice/fix-bug-1"
  echo "Old branch name: $old_branch_name"

  IFS='/' read -ra branch_parts <<< "$old_branch_name"
  if [[ ${#branch_parts[@]} -ne 4 ]]; then
    echo "Error: Branch name must have exactly 4 parts separated by a forward slash. The current branch name is: $old_branch_name" >&2
    return 1
  fi

  local branch_type="${branch_parts[0]}"     # e.g. "feature"
  local branch_username="${branch_parts[2]}" # e.g. "alice"
  local old_description="${branch_parts[3]}" # e.g. "fix-bug-1"

  local new_description
  if [[ -z "${2:-}" ]]; then
    new_description="$old_description"
  else
    new_description="$2"
  fi

  local new_branch_name="$branch_type/$new_app_name/$branch_username/$new_description"
  echo "New branch name: $new_branch_name"

  git switch --create "$new_branch_name"
  git push
  git push origin ":$old_branch_name"            # Delete the old branch on the remote.
  git branch --delete --force "$old_branch_name" # Delete the old branch locally.
)

# "gbr_" is the same as "gbr", but it will omit the branch naming logic.
gbr_() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name is required. Usage: ${FUNCNAME[0]} <branch-name>" >&2
    return 1
  fi
  local new_branch_name="$1"

  local old_branch_name
  old_branch_name=$(git branch --show-current) # e.g. "feature/app1/alice/fix-bug"
  echo "Old branch name: $old_branch_name"
  echo "New branch name: $new_branch_name"

  git switch --create "$new_branch_name"
  git push
  git branch --delete --force "$old_branch_name" # Delete the old branch locally.
  git push origin ":$old_branch_name"            # Delete the old branch on the remote.
)

# "gbs" is short for "git branch squash", which squash all commits on the branch.
gbs() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local branch_name
  branch_name=$(git branch --show-current)

  local merge_base
  merge_base=$(get_merge_base)

  local num_branch_commits
  num_branch_commits=$(git rev-list --count "$merge_base..$branch_name")

  if [[ "$num_branch_commits" -eq 1 ]]; then
    echo "There is only 1 commit on this branch, so no squashing is needed."
    return
  fi

  git reset --soft "HEAD~$num_branch_commits"
  git commit --message "chore: squashed $num_branch_commits commits"
  git push --force-with-lease
)

# "gc" is short for "git commit", which will perform all the steps involved in making a new commit
# with all unstaged changes. The arguments that are provided will be the commit message. If no
# arguments are provided, then the script will attempt to find a suitable commit message.
gc() (
  set -euo pipefail # Exit on errors and undefined variables.

  local amend="false"
  local edit_commit_message="false"
  local commit_message_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --amend)
        amend="true"
        shift
        ;;
      --edit-commit-message)
        edit_commit_message="true"
        shift
        ;;
      *)
        commit_message_args+=("$1")
        shift
        ;;
    esac
  done

  local commit_message="${commit_message_args[*]}"

  assert_git_repository

  if [[ -z "$(git config user.name)" ]]; then
    echo "Error: Git user name not set. Run: git config --global user.name \"Your Name\"" >&2
    return 1
  fi

  if [[ -z "$(git config user.email)" ]]; then
    echo "Error: Git user email not set. Run: git config --global user.email you@example.com" >&2
    return 1
  fi

  if is_github_repository; then
    local user_email
    user_email=$(git config user.email)
    if [[ "$user_email" == *logixhealth.com ]]; then
      echo "Error: You are trying to commit to a GitHub repository with an email of \"$user_email\", which might be a mistake." >&2
      return 1
    fi
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  local repository_has_commits="false"
  if git rev-parse --verify HEAD &> /dev/null; then
    repository_has_commits="true"
  fi

  local has_upstream_config="false"
  if [[ -n "$(git config branch."$branch_name".merge)" ]]; then
    has_upstream_config="true"
  fi

  # Only check for the remote branch existing if:
  # 1) There are one or more commits. (For brand-new repositories, the remote branch will not yet
  #    exist.)
  # 2) This is not a repository from: `gh pr checkout 123`
  if [[ "$repository_has_commits" == "true" ]] && [[ "$has_upstream_config" == "false" ]]; then
    local remote_branch_info
    remote_branch_info=$(git ls-remote --heads origin "$branch_name")

    if [[ -z "$remote_branch_info" ]]; then
      echo "Error: The remote branch of \"$branch_name\" does not yet exist." >&2
      return 1
    fi
  fi

  if [[ "$amend" == "true" ]]; then
    # Validate that we are at the remote tip so that we do not accidentally blow away commits.
    git fetch origin "$branch_name" --quiet
    local latest_commit_local
    latest_commit_local=$(git rev-parse HEAD)
    local latest_commit_remote
    latest_commit_remote=$(git rev-parse "origin/$branch_name")

    if [[ "$latest_commit_local" != "$latest_commit_remote" ]] && ! git merge-base --is-ancestor "$latest_commit_remote" HEAD; then
      echo "Error: Remote branch has commits are not present locally. Do a \"git pull\" first or use a different approach." >&2
      return 1
    fi
  fi

  git add --all

  # Validate that we have one or more new changes to commit. (But allow 0 change commits if we are
  # only editing the commit message.)
  if [[ "$edit_commit_message" == "false" ]] && git diff --cached --quiet; then
    echo "Error: There are no changes to commit."
    return 1
  fi

  if [[ "$amend" == "true" ]]; then
    if [[ "$edit_commit_message" == "true" ]]; then
      # "--amend" amends the previous commit instead of making a new commit.
      # "--allow-empty" allows amending the commit message without changing any files.
      git commit --amend --allow-empty
    else
      # "--amend" amends the previous commit instead of making a new commit.
      # "--no-edit" avoids prompting for a commit message and uses the default commit message.
      git commit --amend --no-edit
    fi

    # We do not need to `git pull` because we already verified above that we are on the remote tip.
    git push --force-with-lease
  else
    if [[ -n "$commit_message" ]]; then
      # A commit message was provided at the command-line. Spell check it using CSpell.
      # - "--no-progress" and "--no-summary" make it only output errors.
      echo "$commit_message" | bunx cspell stdin --no-progress --no-summary
    else
      # A commit message was not provided at the command-line.
      if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        commit_message="chore: update something"
      else
        echo "Getting the commit message from an LLM..."
        commit_message=$(get_llm_commit_message)
      fi
    fi

    git commit --message "$commit_message"

    if [[ "$repository_has_commits" == "true" ]]; then
      git pull --rebase
    fi

    git push
  fi

  gcs
)

# "gca" is short for "git commit amend". This is similar to "gc", but it will amend the previous
# commit and add all unstaged files. Use this sparingly, since it will force push. By default, it
# will use the previous commit message, but you can use "gca edit" (or "gcam") to edit the commit
# message before pushing.
gca() (
  gc --amend
)

# "gcam" is short for "git commit amend message". This is similar to "gca", but it will also allow
# you to change the commit message.
gcam() (
  gc --amend --edit-commit-message
)

# "gcs" is short for "git commit show", which will open a browser to view the last commit.
gcs() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  # e.g. "efe970b4d2d9c7a7023919ea677efce70222c201"
  local commit_sha1
  commit_sha1=$(git rev-parse HEAD)

  # e.g. "git@github.com:alice/my-repo.git" or "https://github.com/alice/my-repo.git"
  local remote_url
  remote_url=$(git remote get-url origin)

  # Remove the trailing ".git" (if present) and then match after the final forward slash.
  local repository_name
  repository_name=$(
    local tmp="${remote_url%.git}"
    echo "${tmp##*/}"
  )

  local commit_url
  if echo "$remote_url" | grep --quiet "github.com"; then
    local repository_owner
    if [[ "$remote_url" == git@* ]]; then
      # SSH URL format: git@github.com:alice/my-repo.git
      repository_owner=$(echo "$remote_url" | sed --regexp-extended 's/^git@github\.com:([^/]+)\/.*\.git/\1/')
    else
      # HTTPS URL format: https://github.com/alice/my-repo.git
      repository_owner=$(echo "$remote_url" | sed --regexp-extended 's|https://github\.com/([^/]+)/.*\.git|\1|')
    fi
    commit_url="https://github.com/$repository_owner/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep --quiet "dev.azure.com"; then
    local organization_name
    organization_name=$(echo "$remote_url" | sed --regexp-extended 's|^git@ssh\.dev\.azure\.com:v3/([^/]+)/.*|\1|')
    local project_name
    project_name=$(echo "$remote_url" | sed --regexp-extended 's|^git@ssh\.dev\.azure\.com:v3/[^/]+/([^/]+)/.*|\1|')
    commit_url="https://dev.azure.com/$organization_name/$project_name/_git/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep --quiet "azuredevops.logixhealth.com"; then
    local organization_name
    organization_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')
    local project_name
    project_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')
    commit_url="https://azuredevops.logixhealth.com/$organization_name/$project_name/_git/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep --quiet "dev.azure.com"; then
    commit_url="https://dev.azure.com/logixhealth/Main/_git/$repository_name/commit/$commit_sha1"
  else
    echo "Failed to parse the remote URL for this repository." >&2
    return 1
  fi

  o "$commit_url"
)

# "gcu" is short for "git commit undo", which will undo the last commit locally (but not on the
# remote).
alias gcu="git reset HEAD~1 --soft"

# "gd" is short for "git diff".
alias gd="git diff"

# This will sync a forked repositories main branch with the upstream. (This is a common operation
# when working on GitHub.)
gh-sync() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_main_branch

  if ! git remote get-url upstream &> /dev/null; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  git fetch origin
  git fetch upstream

  local local_head
  local_head=$(git rev-parse HEAD)
  local remote_head
  remote_head=$(git rev-parse "upstream/$main_branch_name")

  if [[ "$local_head" != "$remote_head" ]]; then
    git rebase "upstream/$main_branch_name"
    git push origin "$main_branch_name" --force-with-lease
  fi
)

# This will delete local branches that have been merged via pull requests on GitHub.
gh-clean() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_main_branch

  if ! git remote get-url upstream &> /dev/null; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if ! command -v gh &> /dev/null; then
    echo "Error: GitHub CLI (gh) is not installed or not in PATH." >&2
    return 1
  fi

  if ! gh auth status &> /dev/null; then
    echo "Error: Not authenticated with GitHub. Run: gh auth login" >&2
    return 1
  fi

  local my_merged_object_ids
  my_merged_object_ids=$(gh pr list --author @me --state merged --json headRefOid --jq ".[].headRefOid")

  if [[ -z "$my_merged_object_ids" ]]; then
    return
  fi

  local local_branches
  local_branches=$(git branch --format="%(refname:short)" | sort)

  while IFS= read -r branch; do
    if [[ "$branch" == "$main_branch_name" ]]; then
      continue
    fi

    local branch_object_id
    branch_object_id=$(git rev-parse "$branch")

    if echo "$my_merged_object_ids" | grep --line-regexp --quiet "$branch_object_id"; then
      echo "GitHub pull request branch has been merged on the upstream: $branch"

      git branch --delete --force "$branch"
      echo "Deleted local branch: $branch"
      git push origin ":$branch"
      echo "Deleted remote branch: $branch"
    fi

  done <<< "$local_branches"
)

# "gl" is short for "git log".
alias gl="git log"

# "glg" is short for "git log --graph" with specific formatting.
alias glg="git log --graph --pretty=format:'%C(yellow)%h%Creset %C(cyan)%d%Creset %C(white)%s%Creset %C(green)(%an)%Creset%n%w(0,8,8)%b%Creset' --all --decorate"

# "gp" is short for "git pull --rebase".
alias gp="git pull --rebase"

# "gpr" is short for "git pull request", to start a new pull request based on the current branch.
# The arguments that are provided will be the pull request title. If no arguments are provided, then
# the script will attempt to find a suitable pull request title.
gpr() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if is_github_repository; then
    gh pr create --fill-first --web
    return
  fi

  if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
    echo "Error: The \"AZDO_PERSONAL_ACCESS_TOKEN\" environment variable is not set. (This is required to automatically open pull requests to Azure DevOps.)" >&2
    return 1
  fi

  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required to automatically open pull requests to Azure DevOps. If you are on Windows, you can install it with: winget install --exact --id jqlang.jq" >&2
    return 1
  fi

  local domain="azuredevops.logixhealth.com"
  local api_version="7.0"

  # e.g. "ssh://azuredevops.logixhealth.com:22/someOrganization/someProject/_git/someRepository"
  # or "https://azuredevops.logixhealth.com/someOrganization/someProject/_git/someRepository"
  local remote_url
  remote_url=$(git remote get-url origin)

  local organization_name
  organization_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')

  local project_name
  project_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')

  # Remove the trailing ".git" (if present) and then match after the final forward slash.
  local repository_name
  repository_name=$(
    local tmp="${remote_url%.git}"
    echo "${tmp##*/}"
  )

  # First, check for an existing pull request.
  local azdo_project_url="https://$domain/$organization_name/$project_name"
  local azdo_api_url="$azdo_project_url/_apis/git/repositories/$repository_name/pullrequests?api-version=$api_version"
  local azdo_api_url_check="$azdo_api_url&searchCriteria.sourceRefName=refs/heads/$branch_name&searchCriteria.status=active"

  local api_response_check
  api_response_check=$(
    curl \
      --silent \
      --fail \
      --show-error \
      --user ":$AZDO_PERSONAL_ACCESS_TOKEN" \
      "$azdo_api_url_check" || {
      local err="$?"
      echo "curl failed on URL: $azdo_api_url_check" >&2
      return "$err"
    }
  )

  local pull_request_count
  pull_request_count=$(echo "$api_response_check" | jq -r '.count')

  local azdo_pull_request_url_prefix="$azdo_project_url/_git/$repository_name/pullrequest"

  if [[ "$pull_request_count" != "0" ]]; then
    local existing_pull_request_id
    existing_pull_request_id=$(echo "$api_response_check" | jq -r '.value[0].pullRequestId')

    local existing_pull_request_url="$azdo_pull_request_url_prefix/$existing_pull_request_id"
    o "$existing_pull_request_url"

    echo "Pull request already exists: $existing_pull_request_url"
    return
  fi

  # Second, use the Azure DevOps API to open a new pull request.
  local pull_request_text
  if [[ $# -eq 0 ]]; then
    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
      # If the user does not have an API key, use a generic pull request title and description.
      echo "Using the first commit description as the pull request title & description."
      pull_request_text=$(get_first_branch_commit_description)
    else
      if [[ $(get_num_commits_on_branch) == "1" ]]; then
        echo "Using the only commit description as the pull request title & description."
        pull_request_text=$(get_first_branch_commit_description)
      else
        echo "Getting the pull request title & description from an LLM..."
        pull_request_text=$(get_llm_pull_request_text)
      fi
    fi
  else
    pull_request_text="$*"
  fi

  local pull_request_title
  pull_request_title=$(echo "$pull_request_text" | head -n 1)

  local pull_request_description
  pull_request_description=$(echo "$pull_request_text" | tail -n +2 | remove_leading_and_trailing_whitespace)
  if [[ -z "$pull_request_description" ]]; then
    pull_request_description="n/a"
  fi

  local json_payload
  json_payload=$(jq -n \
    --arg source "refs/heads/$branch_name" \
    --arg target "refs/heads/$main_branch_name" \
    --arg title "$pull_request_title" \
    --arg desc "$pull_request_description" \
    '{sourceRefName: $source, targetRefName: $target, title: $title, description: $desc}')

  local response_body
  response_body=$(mktemp)
  trap 'rm -f "$response_body"' EXIT

  curl \
    --silent \
    --fail \
    --show-error \
    --output "$response_body" \
    --user ":$AZDO_PERSONAL_ACCESS_TOKEN" \
    --header "Content-Type: application/json" \
    --data "$json_payload" \
    "$azdo_api_url" || {
    local err="$?"
    echo "curl failed on URL: $azdo_api_url" >&2
    echo "data was:"
    echo "$json_payload"
    return "$err"
  }

  # Finally, open the new pull request in a browser so that the user can confirm that everything
  # looks okay.
  local pull_request_id
  pull_request_id=$(jq -r '.pullRequestId' "$response_body")
  local pull_request_url="$azdo_pull_request_url_prefix/$pull_request_id"
  echo "Created pull request: $pull_request_url"
  o "$pull_request_url"
)

# "grb" is short for "git rebase".
alias grb="git rebase"

# "grba" is short for "git rebase --abort".
alias grba="git rebase --abort"

# "grbc" is short for "git rebase --continue". (It will automatically add all files for you.)
grbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  git add --all
  git rebase --continue
)

# "grbm" is short for "git rebase main".
grbm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  git fetch origin "$main_branch_name"
  git rebase "origin/$main_branch_name"
  git push --force-with-lease
)

# "grs" is short for "git reset".
alias grs="git reset"

# "grsh" is short for "git reset --hard".
alias grsh="git reset --hard"

# "grshm" is short for "git reset --hard origin/main".
grshm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  git reset --hard "origin/$main_branch_name"
  git push --force-with-lease
)

# "grt" is short for "git restore". It will the feature branch's merge base as the source.
grt() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository
  assert_feature_branch

  if [[ -z "${1-}" ]]; then
    echo "Error: One or more file paths are required." >&2
    return 1
  fi

  local merge_base
  merge_base=$(get_merge_base)

  git restore --source "$merge_base" "$@"
)

# "grv" is short for "git revert".
grv() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: Commit SHA1 is required. Usage: ${FUNCNAME[0]} <commit_sha1>" >&2
    return 1
  fi
  local commit_sha1="$1"

  git revert "$commit_sha1"
  git push
)

# "grva" is short for "git revert --abort".
alias grva="git revert --abort"

# "grvc" is short for "git revert --continue". (It will automatically add all files for you.)
grvc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  git add --all
  git revert --continue
)

# "grvl" is short for "git revert last". ("grh" is already taken by another command.)
grvl() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  # "--no-edit" avoids prompting for a commit message and uses the default commit message.
  git revert HEAD --no-edit
  git push
  gcs
)

# "gs" is short for "git status --porcelain". (The "--porcelain" flag is preferred since the output
# is more terse.)
alias gs="git status --porcelain"

# "gsq" stands for "git squash", to squash N commits together.
gsq() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: You must provide the number of commits to squash." >&2
    return 1
  fi
  local number_of_commits="$1"

  local commit_message
  if [[ -z "${2:-}" ]]; then
    commit_message="chore: squash $number_of_commits commits"
  else
    commit_message="$2"
  fi

  git reset --soft "HEAD~$number_of_commits"
  git commit --message "$commit_message"
  git push --force-with-lease
)

# "gst" is short for "git stash".
alias gst="git stash"

# "gstd" is short for "git stash drop".
alias gstd="git stash drop"

# "gstl" is short for "git stash list".
alias gstl="git stash list"

# "gstp" is short for "git stash pop"
alias gstp="git stash pop"

# "gsw" is short for "git switch". It requires an argument of the number corresponding to the
# alphabetical local branch. ("gs" is already taken by another command.)
gsw() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name or number is required. Usage: ${FUNCNAME[0]} <branch-name-or-number>" >&2
    return 1
  fi

  local branch_name
  if [[ "$1" =~ ^[0-9]+$ ]]; then
    local branch_number="$1"
    local local_branches
    local_branches=$(git branch --format="%(refname:short)" | sort)
    branch_name=$(echo "$local_branches" | sed -n "${branch_number}p")

    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    branch_name="$1"
  fi

  git switch "$branch_name"
)

# "gswc" is short for "git switch -c". (However, the "gb" command should be used in most contexts.)
alias gswc="git switch -c"

# "gswm" is short for "git switch main".
gswm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  local main_branch_name
  main_branch_name=$(get_main_branch_name)

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before switching to $main_branch_name"
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream &> /dev/null; then
    gh-sync
  else
    git pull --rebase
  fi

  gbc --skip-fetch # git branch clean
  git stash list
)

# "gtc" is short for "git tags clean", which will remote all local tags that do not exist on the
# remote repository.
# https://stackoverflow.com/questions/1841341/remove-local-git-tags-that-are-no-longer-on-the-remote-repository
gtc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert_git_repository

  git tag -l | xargs git tag -d
  git fetch --tags

  echo
  echo "Current git tags:"
  git tag
)

# "gu" is short for "git push".
alias gu="git push"

# "guf" is short for "git push --force-with-lease".
alias guf="git push --force-with-lease"

# ---------------
# Pulumi Commands
# ---------------

# "pd" is short for "pulumi destroy".
alias pd="pulumi destroy"

# "pp" is short for "pulumi preview".
alias pp="pulumi preview"

# "pu" is short for "pulumi up".
alias pu="pulumi up"

# "puy" is short for "pulumi up --yes".
alias puy="pulumi up --yes"

# ------------------
# Terraform Commands
# ------------------

# "ta" is short for "terraform apply".
alias ta="terraform apply"

# "taa" is short for "terraform apply -auto-approve".
alias taa="terraform apply -auto-approve"

# "tc" is short for "terraform clean".
alias tc="rm -rf .terraform .terraform.lock.hcl terraform.tfstate terraform.tfstate.backup"

# "td" is short for "terraform destroy".
alias td="terraform destroy"

# "tda" is short for "terraform destroy -auto-approve".
alias tda="terraform destroy -auto-approve"

# "tf" is short for "terraform fmt".
alias tf="terraform fmt"

# "ti" is short for "terraform init".
alias ti="terraform init"

# "tp" is short for "terraform plan".
alias tp="terraform plan"

# "tv" is short for "terraform validate".
alias tv="terraform validate"

# ------
# Prompt
# ------

# Only change the prompt if the shell is interactive.
if [[ $- == *i* ]]; then
  if ! command -v __git_ps1 &> /dev/null; then
    if [[ -s "/usr/lib/git-core/git-sh-prompt" ]]; then
      # This is the standard location on Ubuntu.
      # shellcheck source=/dev/null
      source "/usr/lib/git-core/git-sh-prompt"
    elif [[ -s "/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh" ]]; then
      # This is the standard location on macOS.
      # shellcheck source=/dev/null
      source "/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh"
    else
      echo "Error: Cannot find the \"__git_ps1\" function declared." >&2
      return 1
    fi
  fi

  if [[ -s "/etc/os-release" ]]; then
    # shellcheck source=/dev/null
    source /etc/os-release
  fi

  if [[ "$ID" == "ubuntu" ]] || [[ "$(uname)" == "Darwin" ]]; then
    # We copy the prompt from Git Bash for Windows:
    # https://github.com/git-for-windows/build-extra/blob/main/git-extra/git-prompt.sh
    PS1='\[\033]0;$TITLEPREFIX:$PWD\007\]' # set window title
    PS1="$PS1"'\n'                         # new line
    PS1="$PS1"'\[\033[32m\]'               # change to green
    PS1="$PS1"'\u@\h '                     # user@host<space>
    # We don't need to show the system, so the next two lines are commented out.
    #PS1="$PS1"'\[\033[35m\]' # change to purple
    #PS1="$PS1"'$MSYSTEM '    # show MSYSTEM
    PS1="$PS1"'\[\033[33m\]' # change to brownish yellow
    PS1="$PS1"'\w'           # current working directory
    GIT_EXEC_PATH="$(git --exec-path 2> /dev/null)"
    COMPLETION_PATH="${GIT_EXEC_PATH%/libexec/git-core}"
    COMPLETION_PATH="${COMPLETION_PATH%/lib/git-core}"
    COMPLETION_PATH="$COMPLETION_PATH/share/git/completion"
    PS1="$PS1"'\[\033[36m\]' # change color to cyan
    PS1="$PS1"'`__git_ps1`'  # bash function
    PS1="$PS1"'\[\033[0m\]'  # change color
    PS1="$PS1"'\n'           # new line
    PS1="$PS1"'$ '           # prompt: always $
  fi
fi
