# shellcheck shell=bash

# Compatibility notes:
# - `mkdir` does not support `--parents` on macOS.
# - `sed` does not support `--quiet` on macOS.

# ----------------
# Helper functions
# ----------------

is_git_bash() (
  set -euo pipefail # Exit on errors and undefined variables.

  local kernel_name
  kernel_name=$(uname -s) # The "--kernel-name" flag is not supported on MacOS.
  [[ "$kernel_name" =~ ^MINGW || "$kernel_name" =~ ^MSYS_NT ]]
)

is_github_repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  # e.g. "git@github.com:alice/my-repo.git" or "https://github.com/alice/my-repo.git"
  local remote_url
  remote_url=$(git remote get-url origin)

  if echo "$remote_url" | grep -q "github.com"; then
    return 0 # True
  else
    return 1 # False
  fi
)

get_first_branch_commit_description() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There was not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi

  local merge_base
  merge_base=$(git merge-base "$main_branch_name" "$branch_name")
  if [[ -z "$merge_base" ]]; then
    echo "Error: Could not find a common ancestor with the \"$main_branch_name\" branch." >&2
    return 1
  fi

  local first_commit_hash
  first_commit_hash=$(git rev-list --reverse "$merge_base..$branch_name" | head -n 1)
  if [[ -z "$first_commit_hash" ]]; then
    echo "Error: There are no commits on this branch when compared to the \"$main_branch_name\" branch." >&2
    return 1
  fi

  printf "%s" "$(git show --no-patch --format="%B" "$first_commit_hash")"
)

# This will return a descriptive commit message based on the currently staged files.
get_llm_commit_message() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    # If the user does not have an API key, return a generic commit message.
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff --cached)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no staged changes in the current Git repository." >&2
    return 1
  fi

  get_llm_output_git_diff "$git_diff" "commit message"
)

# This will return a pull request description based on differences between the current branch and
# the main branch. (Similar to a commit message, the title will be on the first line and the
# description will be on the second line, if any.)
get_llm_pull_request_text() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    # If the user does not have an API key, return a generic commit message.
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff "$main_branch_name"...HEAD)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no changes between this branch and the \"$main_branch_name\" branch." >&2
    return 1
  fi

  get_llm_output_git_diff "$git_diff" "pull request description"
)

get_llm_output_git_diff() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The git diff is required. Usage: get_llm_output_git_diff <git_diff> <noun>" >&2
    return 1
  fi
  local git_diff="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The noun is required. Usage: get_llm_output_git_diff <git_diff> <noun>" >&2
    return 1
  fi
  local noun="$2"

  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required to use the automated commit message feature. If you are on Windows, you can install it with: winget install --exact --id jqlang.jq" >&2
    return 1
  fi

  local system_prompt="You are an expert git commit message generator. You will be given a git diff. Your response must be only the commit message. Be concise and descriptive. The commit message is allowed to be more than one line, but only if the changes are complicated. Follow the 50/72 rule. Follow conventional commit standards (e.g. \"feat: add new feature\", \"fix: correct bug\", \"chore: update build\"). Do not include any preamble, explanation, or markdown."

  local llm_output
  llm_output=$(get_llm_output "$system_prompt" "$git_diff")

  echo -e "$llm_output\n\n(This $noun was automatically generated by an LLM.)"
)

get_llm_output() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The system prompt is required. Usage: get_llm_output <system_prompt> <prompt>" >&2
    return 1
  fi
  local system_prompt="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The prompt is required. Usage: get_llm_output <system_prompt> <prompt>" >&2
    return 1
  fi
  local prompt="$2"

  # Because there can be a huge amount of data in the git diff, we need to create the API response
  # all in one command. Otherwise, we get errors like "Argument list too long".
  # 1. printf pipes the prompt into jq.
  # 2. jq pipes the JSON payload into curl.
  # 3. curl reads from stdin using "--data @-".
  # Additionally, we have to use the "--ssl-no-revoke" flag with Google URLs when using curl inside
  # Git Bash for Windows, since the LogixHealth Palo Alto blocks the revocation check for some
  # reason.
  local api_response
  api_response=$(printf "%s" "$prompt" | jq \
    --raw-input \
    --slurp \
    --arg system_prompt_str "$system_prompt" \
    '{
      "systemInstruction": {
        "parts": [{ "text": $system_prompt_str }]
      },
      "contents": [
        { "parts": [{ "text": . }] }
      ]
     }' | curl \
    --silent \
    --fail \
    --show-error \
    --request POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${GEMINI_API_KEY}" \
    --header "content-type: application/json" \
    --data @- \
    --ssl-no-revoke)

  if ! echo "$api_response" | jq --exit-status '.candidates' > /dev/null; then
    echo "Error: The LLM API returned an error:" >&2
    echo "$api_response" >&2
    return 1
  fi

  local llm_output
  llm_output=$(echo "$api_response" | jq --raw-output '.candidates[0].content.parts[0].text | select(. != null)')

  if [[ -z "$llm_output" ]]; then
    echo "Error: LLM generation failed." >&2
    return 1
  fi

  echo "$llm_output"
)

get_num_github_repository_commits() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: Repository owner is required. Usage: get_num_github_repository_commits <repository_owner> <repository_name>" >&2
    return 1
  fi
  local repository_owner="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: Repository name is required. Usage: get_num_github_repository_commits <repository_owner> <repository_name>" >&2
    return 1
  fi
  local repository_name="$2"

  local response
  response=$(curl \
    --silent \
    --fail \
    --show-error \
    --head \
    "https://api.github.com/repos/$repository_owner/$repository_name/commits?per_page=1")

  if echo "$response" | grep --quiet "404"; then
    echo "Error: Repository \"$repository_owner/$repository_name\" was not found." >&2
    return 1
  fi

  local commit_count
  commit_count=$(echo "$response" | grep -i 'link:' | grep -o 'page=[0-9]*' | tail -1 | cut -d= -f2)

  if [ -n "$commit_count" ]; then
    echo "$commit_count"
  else
    # No pagination implies one page of commits.
    echo "1"
  fi
)

# -------
# Version
# -------

BASH_PROFILE_VERSION=$(get_num_github_repository_commits Zamiell configs)
export BASH_PROFILE_VERSION
version() (
  echo "Remote Bash profile version: $BASH_PROFILE_VERSION"
)

# Only print the version if the shell is interactive.
if [[ $- == *i* ]]; then
  version
fi

# ---------------------
# Environment Variables
# ---------------------

# Load secret environment variables that cannot be committed to Git.
if [[ -f "$HOME/.env" ]]; then
  # shellcheck source=/dev/null
  source "$HOME/.env"
fi

# Fix self-signed certs for LogixHealth.
if [[ -f "/usr/local/share/ca-certificates/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/usr/local/share/ca-certificates/BEDROOTCA001.crt"
elif [[ -f "/c/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/tls/BEDROOTCA001.crt"
elif [[ -f "/c/_IT/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/_IT/tls/BEDROOTCA001.crt"
fi
if [[ -n "${COMPANY_CERT_PATH-}" ]]; then
  export NODE_EXTRA_CA_CERTS="$COMPANY_CERT_PATH"
  export CURL_CA_BUNDLE="$COMPANY_CERT_PATH"
fi
if [[ -f "/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -f "/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -f "/opt/az/lib/python3.13/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/opt/az/lib/python3.13/site-packages/certifi/cacert.pem"
fi

# Add browsers to the path, which is necessary for the GitHub CLI.
if ! command -v chrome &> /dev/null && [[ -f "/c/Program Files/Google/Chrome/Application/chrome.exe" ]]; then
  export PATH="$PATH:/c/Program Files/Google/Chrome/Application"
fi
if ! command -v chrome &> /dev/null && command -v google-chrome &> /dev/null; then
  alias chrome="google-chrome"
fi
if ! command -v msedge &> /dev/null && [[ -f "/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" ]]; then
  export PATH="$PATH:/c/Program Files (x86)/Microsoft/Edge/Application"
fi
if ! command -v msedge &> /dev/null && command -v microsoft-edge-stable &> /dev/null; then
  alias msedge="microsoft-edge-stable"
fi

# Get the username is a platform-agnostic way.
if [[ -n "$USER" ]]; then
  export OS_USERNAME="$USER"
elif [[ -n "$USERNAME" ]]; then
  export OS_USERNAME="$USERNAME"
else
  echo "Failed to derive the operating system username." >&2
fi

# ----------------------
# Miscellaneous Commands
# ----------------------

ai() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ $# -eq 0 ]]; then
    echo "Error: The prompt is required. Usage: ai <prompt>" >&2
    return 1
  fi
  local prompt="$*"

  local system_prompt="You are an expert full-stack systems engineer. You will be given an English description of a Linux/Bash command. Your response must be a Linux/Bash command that matches the description, to the best of your ability. Only include the command, as it will be copy-pasted by the user. Do not include any preamble, explanation, or markdown. If the command includes flags, always include the long-form version of the flag, if available."

  get_llm_output "$system_prompt" "$prompt"
)

# Only create this alias if the shell is interactive.
if [[ $- == *i* ]]; then
  # Automatically list the contents of a directory after changing to it.
  # (We have to use braces instead of parenthesis here.)
  cd() {
    # We use the same flags as the "ll" alias.
    # (We do not use the alias directly for compatibility reasons.)
    builtin cd "$@" && ls -a -h -l -F
  }
fi

# It is annoying that Claude Code requires permission to edit files on every invocation.
alias claude="claude --permission-mode acceptEdits"

# "csf" is short for "bunx cspell-check-unused-words --fix".
csf() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  bunx cspell-check-unused-words --fix

  if [[ -n "$(git status --porcelain)" ]]; then
    gc "chore: removing unused words from the CSpell configuration file"
  fi
)

# Alias "explorer" to "open" on macOS and "xdg-open" on Linux.
explorer() (
  set -euo pipefail # Exit on errors and undefined variables.

  if command -v explorer &> /dev/null; then
    # We must use "command" to invoke "explorer" to prevent an infinite loop.
    command explorer "$@"
  else
    if [[ "$(uname)" == "Darwin" ]]; then
      open "$@"
    else
      xdg-open "$@"
    fi
  fi
)

# A better "ll" alias that shows human-readable file sizes.
# (macOS does not support any of the long-form flags, so we use the short ones instead.)
# - "-a" is short for "--all", which shows hidden files.
# - "-h" is short for "--human-readable", which converts bytes to kilobytes and so on.
# - "-F" is short for "--classify", which displays extra characters to signify the file type.
alias ll="ls -a -h -l -F"

# "n" is short for "nuke".
alias n="npx complete-cli@latest nuke"

# "o" is short for "open", to open a URL in a browser.
o() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: URL is required. Usage: o <url>" >&2
    return 1
  fi
  local url="$1"

  if [[ "$url" == *"logixhealth"* ]] && command -v msedge &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    msedge "$url" > /dev/null
    return 0
  fi

  if command -v chrome &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    chrome "$url" > /dev/null
    return 0
  fi

  # macOS and Linux have the "open" command:
  # https://ss64.com/mac/open.html
  if command -v open &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    open "$url" > /dev/null
    return 0
  fi

  echo "Git commit URL is at:"
  echo "$url"
)

# "r" is short for switching to the repositories directory.
if [[ -d "/c/Users/$OS_USERNAME/Repositories" ]]; then # Generic Windows
  REPOSITORIES_DIRECTORY="/c/Users/$OS_USERNAME/Repositories"
elif [[ -d "/Users/$OS_USERNAME/repositories" ]]; then # Generic MacOS (1/2)
  REPOSITORIES_DIRECTORY="/Users/$OS_USERNAME/repositories"
elif [[ -d "/Users/$OS_USERNAME/Repositories" ]]; then # Generic MacOS (2/2)
  REPOSITORIES_DIRECTORY="/Users/$OS_USERNAME/Repositories"
elif [[ -d "/home/$OS_USERNAME/repositories" ]]; then # Generic Linux (1/2)
  REPOSITORIES_DIRECTORY="/home/$OS_USERNAME/repositories"
elif [[ -d "/home/$OS_USERNAME/Repositories" ]]; then # Generic Linux (2/2)
  REPOSITORIES_DIRECTORY="/home/$OS_USERNAME/Repositories"
elif [[ -d "/c/Repositories" ]]; then # Windows C drive
  REPOSITORIES_DIRECTORY="/c/Repositories"
elif [[ -d "/d/Repositories" ]]; then # Windows D drive
  REPOSITORIES_DIRECTORY="/d/Repositories"
fi
if [[ -n "$REPOSITORIES_DIRECTORY" ]]; then
  alias r='builtin cd $REPOSITORIES_DIRECTORY'

  # Only automatically change directories if the shell is interactive.
  if [[ $- == *i* ]]; then
    builtin cd "$REPOSITORIES_DIRECTORY"
  fi
fi

# Establishes a connection to the LogixHealth VPN in the background. (This is intended to be used on
# Linux devices.)
vpn() (
  set -euo pipefail # Exit on errors and undefined variables.

  MICROSOFT_EDGE_PATH="/opt/microsoft/msedge/msedge"
  if [[ ! -f "$MICROSOFT_EDGE_PATH" ]]; then
    echo "Error: Microsoft Edge must be installed at: $MICROSOFT_EDGE_PATH" >&2
    return 1
  fi

  sudo killall gpclient
  sudo nohup gpclient connect lhvpn.logixhealth.com --browser "$MICROSOFT_EDGE_PATH" &
)

# ----------------
# kubectl Commands
# ----------------

alias k="kubectl"
alias kdd="kubectl describe deployment"
alias kdp="kubectl describe pod"
alias kds="kubectl describe service"
alias kgd="kubectl get deployment"
alias kgp="kubectl get pod"

# ------------
# npm Commands
# ------------

get_package_manager() (
  set -euo pipefail # Exit on errors and undefined variables.

  local current_dir="$PWD"

  # Search upward through directories, looking for package lock files.
  while [ "$current_dir" != "/" ]; do
    if [ -f "$current_dir/package-lock.json" ]; then
      echo "npm"
      return 0
    elif [ -f "$current_dir/yarn.lock" ]; then
      echo "yarn"
      return 0
    elif [ -f "$current_dir/pnpm-lock.yaml" ]; then
      echo "pnpm"
      return 0
    elif [ -f "$current_dir/bun.lock" ]; then
      echo "bun"
      return 0
    fi

    current_dir="$(dirname "$current_dir")"
  done

  echo "Error: Not able to determine the package manager for the current project." >&2
  return 1
)

run_package_script() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [ -z "${1-}" ]; then
    echo "Error: Script name is required." >&2
    return 1
  fi

  local package_manager
  package_manager="$(get_package_manager)"
  if [ -z "$package_manager" ]; then
    echo "Error: Failed to find the package manager." >&2
    return 1
  fi

  "$package_manager" run "$@"
)

alias b="run_package_script build"
alias l="run_package_script lint"
alias la="run_package_script lint-all"
alias p="run_package_script publish"
alias s="run_package_script start"
alias t="run_package_script test"
alias u="run_package_script update || bunx complete-cli@latest update"

alias cu="bunx cspell-check-unused-words --fix"

# "ua" is short for "update all", which will recursively update all "package.json" files from the
# current working directory.
ua() (
  set -euo pipefail # Exit on errors and undefined variables.

  local package_json_files
  package_json_files="$(find . -name node_modules -prune -o -name package.json -print)"

  while IFS= read -r package_json; do
    if [[ -n "$package_json" ]]; then
      local package_json_dir
      package_json_dir="$(dirname "$package_json")"
      echo
      echo "Updating packages in: $package_json_dir"
      echo
      (cd "$package_json_dir" && u)
    fi
  done <<< "$package_json_files"
)

# ----------
# Git Config
# ----------

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreautocrlf
# Default value: input
# Explicitly setting it to false prevents Git from changing line endings at any point, which can
# prevent issues when Windows users collaborate with MacOS/Linus users.
git config --global core.autocrlf false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreignoreCase
# Default value: false (on Linux machines) or true (on Windows machines)
# Explicitly setting it to false can prevent problems with interop between Linux & Windows.
git config --global core.ignorecase false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-diffcolorMoved
# Default value: false
# Setting zebra can make git diffs easier to read by having a different color for moved lines.
git config --global diff.colorMoved zebra

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchprune
# Default value: false
# Automatically remove any remote-tracking references that no longer exist on the remote.
git config --global fetch.prune true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchpruneTags
# Default value: false
# Automatically remove any tags that no longer exist on the remote.
git config --global fetch.pruneTags true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pullrebase
# Default value: false
# Setting this prevents spurious merge commits.
git config --global pull.rebase true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pushautoSetupRemote
# Default value: false
# Setting this automates having "git pull" and "git push" work properly after setting up a new
# branch.
git config --global push.autoSetupRemote true

# ------------
# Git Commands
# ------------

# "ga" is short for "git add".
alias ga="git add"

# "gaa" is short for "git add --all".
alias gaa="git add --all"

# - "gb" is short for creating a new git branch, which is a common coding task.
# - If the remote repository is not GitHub, this will make the branch according to the LogixHealth
#   branch naming convention.
# - Doing a push is important after creating a new branch because it prevents subsequent `git pull`
#   calls from failing.
gb() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    local description="misc"
  else
    local description="$1"
  fi

  if [[ -z "${2:-}" ]]; then
    local application_name="misc"
  else
    local application_name="$2"
  fi

  if is_github_repository; then
    local new_branch_name="$description"
  else
    local new_branch_name="feature/$application_name/$OS_USERNAME/$description"
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before creating a new git branch"
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream > /dev/null 2>&1; then
    gh-sync
  else
    git pull --rebase
  fi

  git switch --create "$new_branch_name"
  git push

  if [[ $(git stash list | wc -l) -gt 0 ]]; then
    echo "A previous git stash exists. Applying it to this new branch."
    git stash pop
  fi

  echo
  gbl
)

# "gb_" is the same thing as "gb", but if the remote repository is not GitHub, it will omit the
# branch naming logic.
gb_() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    local new_branch_name="misc"
  else
    local new_branch_name="$1"
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before creating a new git branch"
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream > /dev/null 2>&1; then
    gh-sync
  else
    git pull --rebase
  fi

  git switch --create "$new_branch_name"
  git push

  if [[ $(git stash list | wc -l) -gt 0 ]]; then
    echo "A previous git stash exists. Applying it to this new branch."
    git stash pop
  fi

  echo
  gbl
)

# "gbc" is short for "git branch clean", which will remove all local branches that do not exist on
# the remote repository.
# https://stackoverflow.com/questions/7726949/remove-tracking-branches-no-longer-on-remote
gbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  local skip_fetch=false
  for arg in "$@"; do
    if [[ "$arg" == "--skip-fetch" ]]; then
      skip_fetch=true
    fi
  done

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if [[ "$skip_fetch" == false ]]; then
    git fetch --prune --quiet
  fi

  git branch -vv | awk "/: gone]/{print \$1}" | xargs --no-run-if-empty git branch --delete --force

  # Additionally, we want to delete branches from merged pull requests.
  if git remote get-url upstream > /dev/null 2>&1; then
    gh-clean
  fi

  echo
  gbl
)

# "gbd" is short for "git branch delete", which will delete the branch both locally and remotely.
gbd() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name or number is required. Usage: gbd <branch-name-or-number>" >&2
    return 1
  fi

  if [[ "$1" =~ ^[0-9]+$ ]]; then
    local branch_number="$1"
    local local_branches
    local_branches=$(git branch --format="%(refname:short)" | sort)
    local branch_name
    branch_name=$(echo "$local_branches" | sed -n "${branch_number}p")

    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    local branch_name="$1"
  fi

  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git branch --delete --force "$branch_name"
    echo "Deleted branch \"$branch_name\" locally."
  else
    echo "Warning: Branch \"$branch_name\" does not exist locally."
  fi

  if git ls-remote --heads origin "$branch_name" | grep -q .; then
    git push origin ":$branch_name"
    echo "Deleted branch \"$branch_name\" remotely."
  else
    echo "Warning: Branch \"$branch_name\" does not exist on remote origin."
  fi

  echo
  gbl
)

# "gbdl" is short for "git branch delete local", which will delete the branch locally (and not
# remotely).
gbdl() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name or number is required. Usage: gbdl <branch-name-or-number>" >&2
    return 1
  fi

  if [[ "$1" =~ ^[0-9]+$ ]]; then
    local branch_number="$1"
    local local_branches
    local_branches=$(git branch --format="%(refname:short)" | sort)
    local branch_name
    branch_name=$(echo "$local_branches" | sed -n "${branch_number}p")

    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    local branch_name="$1"
  fi

  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git branch --delete --force "$branch_name"
    echo "Deleted branch \"$branch_name\" locally."
  else
    echo "Warning: Branch \"$branch_name\" does not exist locally."
  fi

  echo
  gbl
)

# "gbl" is short for "git branch list". ("gb" is already taken by another command.)
gbl() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  local local_branches
  local_branches=$(git branch --format="%(refname:short)" | sort)
  local current_branch
  current_branch=$(git branch --show-current)

  local GREEN_CODE='\033[32m'
  local RESET_CODE='\033[0m'

  echo "Current git branches:"

  local count=1
  while IFS= read -r branch; do
    if [[ "$branch" == "$current_branch" ]]; then
      echo -e "${GREEN_CODE}* ${count} - ${branch}${RESET_CODE}"
    else
      echo "  ${count} - ${branch}"
    fi

    ((count++))
  done <<< "$local_branches"
)

# "gblr" is short for "git branch list remote".
gblr() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  git fetch --prune --quiet

  local remote_branches
  remote_branches=$(git branch --format="%(refname:short)" --remotes | grep --invert-match --line-regexp "origin" | grep --invert-match "^origin/" | sort)

  echo "Remote git branches:"

  local count=1
  while IFS= read -r branch; do
    echo "  ${count} - ${branch}"
    ((count++))
  done <<< "$remote_branches"
)

# "gbr" is short for "git branch rename", which will rename the application and/or description
# portion of a LogixHealth branch name.
gbr() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Application name is required. Usage: gbr <application-name> [description]" >&2
    return 1
  fi
  local new_app_name="$1"

  local old_branch_name
  old_branch_name=$(git branch --show-current) # e.g. "feature/misc/alice/fix-bug-1"
  echo "Old branch name: $old_branch_name"

  IFS='/' read -ra branch_parts <<< "$old_branch_name"
  if [[ ${#branch_parts[@]} -ne 4 ]]; then
    echo "Error: Branch name must have exactly 4 parts separated by a forward slash. The current branch name is: $old_branch_name" >&2
    return 1
  fi

  local branch_type="${branch_parts[0]}"     # e.g. "feature"
  local branch_username="${branch_parts[2]}" # e.g. "alice"
  local old_description="${branch_parts[3]}" # e.g. "fix-bug-1"

  if [[ -z "${2:-}" ]]; then
    local new_description="$old_description"
  else
    local new_description="$2"
  fi

  local new_branch_name="$branch_type/$new_app_name/$branch_username/$new_description"
  echo "New branch name: $new_branch_name"

  git switch --create "$new_branch_name"
  git push
  git push origin ":$old_branch_name"            # Delete the old branch on the remote.
  git branch --delete --force "$old_branch_name" # Delete the old branch locally.
)

# "gbr_" is the same as "gbr", but it will omit the branch naming logic.
gbr_() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name is required. Usage: gbr_ <branch-name>" >&2
    return 1
  fi
  local new_branch_name="$1"

  local old_branch_name
  old_branch_name=$(git branch --show-current) # e.g. "feature/app1/alice/fix-bug"
  echo "Old branch name: $old_branch_name"
  echo "New branch name: $new_branch_name"

  git switch --create "$new_branch_name"
  git push
  git branch --delete --force "$old_branch_name" # Delete the old branch locally.
  git push origin ":$old_branch_name"            # Delete the old branch on the remote.
)

# "gbs" is short for "git branch squash", which squash all commits on the branch.
gbs() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi

  local merge_base
  merge_base=$(git merge-base "$main_branch_name" "$branch_name")
  if [[ -z "$merge_base" ]]; then
    echo "Error: Could not find a common ancestor with the \"$main_branch_name\" branch." >&2
    return 1
  fi

  local num_branch_commits
  num_branch_commits=$(git rev-list --count "$merge_base..$branch_name")

  if [[ "$num_branch_commits" -eq 1 ]]; then
    echo "There is only 1 commit on this branch, so no squashing is needed."
    return 0
  fi

  git reset --soft "HEAD~$num_branch_commits"
  git commit --message "chore: squashed $num_branch_commits commits"
  git push --force
)

# "gc" is short for "git commit", which will perform all the steps involved in making a new commit
# with all unstaged changes. The arguments that are provided will be the commit message. If no
# arguments are provided, then a default commit message will be used.
gc() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "$(git config user.name)" ]]; then
    echo "Error: Git user name not set. Run: git config --global user.name \"Your Name\"" >&2
    return 1
  fi

  if [[ -z "$(git config user.email)" ]]; then
    echo "Error: Git user email not set. Run: git config --global user.email you@example.com" >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  # Only check for the remote branch existing if there are one or more commits. (For brand-new
  # repositories, the remote branch will not yet exist.)
  if git rev-parse --verify HEAD > /dev/null 2>&1; then
    local remote_branch_info
    remote_branch_info=$(git ls-remote --heads origin "$branch_name")

    if [[ -z "$remote_branch_info" ]]; then
      echo "Error: The remote branch of \"$branch_name\" does not yet exist." >&2
      return 1
    fi
  fi

  if is_github_repository; then
    local user_email
    user_email=$(git config user.email)
    if [[ "$user_email" == *@logixhealth.com ]]; then
      echo "Error: You are trying to commit to a GitHub repository with an email of \"$user_email\", which might be a mistake." >&2
      return 1
    fi
  fi

  git add --all
  if git diff --cached --quiet; then
    echo "Error: There are no changes to commit."
    return 1
  fi

  local commit_message
  if [[ $# -eq 0 ]]; then
    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
      commit_message="chore: update something"
    else
      commit_message=$(get_llm_commit_message)
    fi
  else
    commit_message="$*"
  fi

  git commit --message "$commit_message"
  git pull --rebase
  git push

  gcs
)

# "gca" is short for "git commit amend". This is similar to "gc", but it will amend the previous
# commit and add all unstaged files. Use this sparingly, since it will force push. By default, it
# will use the previous commit message, but you can use "gca edit" (or "gcam") to edit the commit
# message before pushing.
gca() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ "${1:-}" == "edit" ]]; then
    local edit="true"
  else
    local edit="false"
  fi

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  # Only check for the remote branch existing if there are one or more commits. (For brand-new
  # repositories, the remote branch will not yet exist.)
  if git rev-parse --verify HEAD > /dev/null 2>&1; then
    local remote_branch_info
    remote_branch_info=$(git ls-remote --heads origin "$branch_name")

    if [[ -z "$remote_branch_info" ]]; then
      echo "Error: The remote branch of \"$branch_name\" does not yet exist." >&2
      return 1
    fi
  fi

  # Validate that we are at the remote tip so that we do not accidentally blow away commits.
  git fetch origin "$branch_name" --quiet
  local latest_commit_local
  latest_commit_local=$(git rev-parse HEAD)
  local latest_commit_remote
  latest_commit_remote=$(git rev-parse "origin/$branch_name")

  if [[ "$latest_commit_local" != "$latest_commit_remote" ]] && ! git merge-base --is-ancestor "$latest_commit_remote" HEAD; then
    echo "Error: Remote branch has commits are not present locally. Do a \"git pull\" first or use a different approach." >&2
    return 1
  fi

  git add --all
  if [[ "$edit" == "true" ]]; then
    # "--amend" amends the previous commit instead of making a new commit.
    git commit --amend
  else
    # "--amend" amends the previous commit instead of making a new commit.
    # "--no-edit" avoids prompting for a commit message and uses the default commit message.
    git commit --amend --no-edit
  fi
  git push --force

  gcs
)

# "gcam" is short for "git commit amend message". This is similar to "gca", but it will also allow
# you to change the commit message.
gcam() (
  set -euo pipefail # Exit on errors and undefined variables.

  gca edit
)

# "gcs" is short for "git commit show", which will open a browser to view the last commit.
gcs() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  # e.g. "efe970b4d2d9c7a7023919ea677efce70222c201"
  local commit_sha1
  commit_sha1=$(git rev-parse HEAD)

  # e.g. "git@github.com:alice/my-repo.git" or "https://github.com/alice/my-repo.git"
  local remote_url
  remote_url=$(git remote get-url origin)

  # Remove the trailing ".git" (if present) and then match after the final forward slash.
  local repository_name
  repository_name=$(
    local tmp="${remote_url%.git}"
    echo "${tmp##*/}"
  )

  if echo "$remote_url" | grep -q "github.com"; then
    if [[ "$remote_url" == git@* ]]; then
      # SSH URL format: git@github.com:alice/my-repo.git
      local repository_owner
      repository_owner=$(echo "$remote_url" | sed -E 's/^git@github\.com:([^/]+)\/.*\.git/\1/')
    else
      # HTTPS URL format: https://github.com/alice/my-repo.git
      local repository_owner
      repository_owner=$(echo "$remote_url" | sed -E 's|https://github\.com/([^/]+)/.*\.git|\1|')
    fi
    local commit_url="https://github.com/$repository_owner/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep -q "dev.azure.com"; then
    local organization_name
    organization_name=$(echo "$remote_url" | sed -E 's|^git@ssh\.dev\.azure\.com:v3/([^/]+)/.*|\1|')
    local project_name
    project_name=$(echo "$remote_url" | sed -E 's|^git@ssh\.dev\.azure\.com:v3/[^/]+/([^/]+)/.*|\1|')
    local commit_url="https://dev.azure.com/$organization_name/$project_name/_git/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep -q "azuredevops.logixhealth.com"; then
    local organization_name
    organization_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')
    local project_name
    project_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')
    local commit_url="https://azuredevops.logixhealth.com/$organization_name/$project_name/_git/$repository_name/commit/$commit_sha1"
  elif echo "$remote_url" | grep -q "dev.azure.com"; then
    local commit_url="https://dev.azure.com/logixhealth/Main/_git/$repository_name/commit/$commit_sha1"
  else
    echo "Failed to parse the remote URL for this repository." >&2
    return 1
  fi

  o "$commit_url"
)

# "gcu" is short for "git commit undo", which will undo the last commit locally (but not on the
# remote).
alias gcu="git reset HEAD~1 --soft"

# "gd" is short for "git diff".
alias gd="git diff"

# This will sync a forked repositories main branch with the upstream. (This is a common operation
# when working on GitHub.)
gh-sync() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if ! git remote get-url upstream > /dev/null 2>&1; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)
  if [[ "$current_branch" != "$main_branch_name" ]]; then
    echo "You can only sync the \"$main_branch_name\" branch. Right now, you currently on branch: $current_branch" >&2
    return 1
  fi

  git fetch origin
  git fetch upstream

  local local_head
  local_head=$(git rev-parse HEAD)
  local remote_head
  remote_head=$(git rev-parse "upstream/$main_branch_name")

  if [[ "$local_head" != "$remote_head" ]]; then
    git rebase "upstream/$main_branch_name"
    git push origin "$main_branch_name" --force-with-lease
  fi
)

# This will delete local branches that have been merged via pull requests on GitHub.
gh-clean() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if ! git remote get-url upstream > /dev/null 2>&1; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  local current_branch
  current_branch=$(git branch --show-current)
  if [[ "$current_branch" != "$main_branch_name" ]]; then
    echo "You can only clean up branches up from the \"$main_branch_name\" branch. Right now, you currently on branch: $current_branch" >&2
    return 1
  fi

  if ! command -v gh > /dev/null 2>&1; then
    echo "Error: GitHub CLI (gh) is not installed or not in PATH." >&2
    return 1
  fi

  if ! gh auth status > /dev/null 2>&1; then
    echo "Error: Not authenticated with GitHub. Run: gh auth login" >&2
    return 1
  fi

  local my_merged_object_ids
  my_merged_object_ids=$(gh pr list --author @me --state merged --json headRefOid --jq ".[].headRefOid")

  if [[ -z "$my_merged_object_ids" ]]; then
    return
  fi

  local local_branches
  local_branches=$(git branch --format="%(refname:short)" | sort)

  while IFS= read -r branch; do
    if [[ "$branch" == "$main_branch_name" ]]; then
      continue
    fi

    local branch_object_id
    branch_object_id=$(git rev-parse "$branch")

    if echo "$my_merged_object_ids" | grep --line-regexp --quiet "$branch_object_id"; then
      echo "GitHub pull request branch has been merged on the upstream: $branch"

      git branch --delete --force "$branch"
      echo "Deleted local branch: $branch"
      git push origin ":$branch"
      echo "Deleted remote branch: $branch"
    fi

  done <<< "$local_branches"
)

# "gl" is short for "git log".
alias gl="git log"

# "glg" is short for "git log --graph" with specific formatting.
alias glg="git log --graph --pretty=format:'%C(yellow)%h%Creset %C(cyan)%d%Creset %C(white)%s%Creset %C(green)(%an)%Creset%n%w(0,8,8)%b%Creset' --all --decorate"

# "gp" is short for "git pull --rebase".
alias gp="git pull --rebase"

# "gpr" is short for "git pull request", to start a new pull request based on the current branch.
gpr() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi

  if is_github_repository; then
    gh pr create --fill-first --web
    return
  fi

  if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
    echo "Error: The \"AZDO_PERSONAL_ACCESS_TOKEN\" environment variable is not set. (This is required to automatically open pull requests to Azure DevOps.)" >&2
    return 1
  fi

  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required to automatically open pull requests to Azure DevOps. If you are on Windows, you can install it with: winget install --exact --id jqlang.jq" >&2
    return 1
  fi

  local domain="azuredevops.logixhealth.com"
  local api_version="7.0"

  # e.g. "ssh://azuredevops.logixhealth.com:22/someOrganization/someProject/_git/someRepository"
  # or "https://azuredevops.logixhealth.com/someOrganization/someProject/_git/someRepository"
  local remote_url
  remote_url=$(git remote get-url origin)

  local organization_name
  organization_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')

  local project_name
  project_name=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')

  # Remove the trailing ".git" (if present) and then match after the final forward slash.
  local repository_name
  repository_name=$(
    local tmp="${remote_url%.git}"
    echo "${tmp##*/}"
  )

  # First, check for an existing pull request.
  local azdo_project_url="https://$domain/$organization_name/$project_name"
  local azdo_api_url="$azdo_project_url/_apis/git/repositories/$repository_name/pullrequests?api-version=$api_version"
  local azdo_api_url_check="$azdo_api_url&searchCriteria.sourceRefName=refs/heads/$branch_name&searchCriteria.status=active"

  local api_response_check
  api_response_check=$(curl \
    --silent \
    --fail \
    --show-error \
    --user ":$AZDO_PERSONAL_ACCESS_TOKEN" \
    "$azdo_api_url_check")

  local pull_request_count
  pull_request_count=$(echo "$api_response_check" | jq -r '.count')

  local azdo_pull_request_url_prefix="$azdo_project_url/_git/$repository_name/pullrequest"

  if [[ "$pull_request_count" != "0" ]]; then
    local existing_pull_request_id
    existing_pull_request_id=$(echo "$api_response_check" | jq -r '.value[0].pullRequestId')

    local existing_pull_request_url="$azdo_pull_request_url_prefix/$existing_pull_request_id"
    o "$existing_pull_request_url"

    echo "Pull request already exists: $existing_pull_request_url"
    return
  fi

  # Second, use the Azure DevOps API to open a new pull request.
  local pull_request_title
  local pull_request_description

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    # If the user does not have an API key, use a generic pull request title and description.
    pull_request_title=$(get_first_branch_commit_description)
    pull_request_description="n/a"
  else
    local pull_request_text
    pull_request_text=$(get_llm_pull_request_text)
    pull_request_title=$(echo "$pull_request_text" | head -n 1)
    pull_request_description=$(echo "$pull_request_text" | tail -n +2)
  fi

  local json_payload
  json_payload=$(jq -n \
    --arg source "refs/heads/$branch_name" \
    --arg target "refs/heads/$main_branch_name" \
    --arg title "$pull_request_title" \
    --arg desc "$pull_request_description" \
    '{sourceRefName: $source, targetRefName: $target, title: $title, description: $desc}')

  local response_body
  response_body=$(mktemp)
  trap 'rm -f "$response_body"' EXIT

  curl \
    --silent \
    --fail \
    --show-error \
    --output "$response_body" \
    --user ":$AZDO_PERSONAL_ACCESS_TOKEN" \
    --header "Content-Type: application/json" \
    --data "$json_payload" \
    "$azdo_api_url"

  # Finally, open the new pull request in a browser so that the user can confirm that everything
  # looks okay.
  local pull_request_id
  pull_request_id=$(jq -r '.pullRequestId' "$response_body")
  local pull_request_url="$azdo_pull_request_url_prefix/$pull_request_id"
  o "$pull_request_url"
)

# "grb" is short for "git rebase".
alias grb="git rebase"

# "grba" is short for "git rebase --abort".
alias grba="git rebase --abort"

# "grbc" is short for "git rebase --continue". (It will automatically add all files for you.)
grbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  git add --all
  git rebase --continue
)

# "grbm" is short for "git rebase main".
grbm() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ "$(git branch --show-current)" == "$main_branch_name" ]]; then
    echo "You are on the \"$main_branch_name\" branch, so you cannot rebase this branch on itself." >&2
    return 1
  fi

  git fetch origin $main_branch_name
  git rebase origin/$main_branch_name
  git push --force
)

# "grs" is short for "git reset".
alias grs="git reset"

# "grsh" is short for "git reset --hard".
alias grsh="git reset --hard"

# "grv" is short for "git revert".
grv() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Commit SHA1 is required. Usage: grv <commit_sha1>" >&2
    return 1
  fi
  local commit_sha1="$1"

  git revert "$commit_sha1"
  git push
)

# "grva" is short for "git revert --abort".
alias grva="git revert --abort"

# "grvc" is short for "git revert --continue". (It will automatically add all files for you.)
grvc() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  git add --all
  git revert --continue
)

# "grvl" is short for "git revert last". ("grh" is already taken by another command.)
grvl() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  # "--no-edit" avoids prompting for a commit message and uses the default commit message.
  git revert HEAD --no-edit
  git push
  gcs
)

# "gs" is short for "git status --porcelain". (The "--porcelain" flag is preferred since the output
# is more terse.)
alias gs="git status --porcelain"

# "gsq" stands for "git squash", to squash N commits together.
gsq() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: You must provide the number of commits to squash." >&2
    return 1
  fi
  local number_of_commits="$1"

  if [[ -z "${2:-}" ]]; then
    local commit_message="chore: squash $number_of_commits commits"
  else
    local commit_message="$2"
  fi

  git reset --soft "HEAD~$number_of_commits"
  git commit --message "$commit_message"
  git push --force
)

# "gst" is short for "git stash".
alias gst="git stash"

# "gstd" is short for "git stash drop".
alias gstd="git stash drop"

# "gstl" is short for "git stash list".
alias gstl="git stash list"

# "gstp" is short for "git stash pop"
alias gstp="git stash pop"

# "gsw" is short for "git switch". It requires an argument of the number corresponding to the
# alphabetical local branch. ("gs" is already taken by another command.)
gsw() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name or number is required. Usage: gsw <branch-name-or-number>" >&2
    return 1
  fi

  if [[ "$1" =~ ^[0-9]+$ ]]; then
    local branch_number="$1"
    local local_branches
    local_branches=$(git branch --format="%(refname:short)" | sort)
    local branch_name
    branch_name=$(echo "$local_branches" | sed -n "${branch_number}p")

    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    local branch_name="$1"
  fi

  git switch "$branch_name"
)

# "gswc" is short for "git switch -c". (However, the "gb" command should be used in most contexts.)
alias gswc="git switch -c"

# "gswm" is short for "git switch main".
gswm() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  if git show-ref --verify --quiet refs/heads/main; then
    local main_branch_name="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    local main_branch_name="master"
  else
    echo "Error: There is not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before switching to $main_branch_name"
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream > /dev/null 2>&1; then
    gh-sync
  else
    git pull --rebase
  fi

  gbc --skip-fetch # git branch clean
  git stash list
)

# "gtc" is short for "git tags clean", which will remote all local tags that do not exist on the
# remote repository.
# https://stackoverflow.com/questions/1841341/remove-local-git-tags-that-are-no-longer-on-the-remote-repository
gtc() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not inside a Git repository." >&2
    return 1
  fi

  git tag -l | xargs git tag -d
  git fetch --tags

  echo
  echo "Current git tags:"
  git tag
)

# "gu" is short for "git push".
alias gu="git push"

# "guf" is short for "git push --force".
alias guf="git push --force"

# ---------------
# Pulumi Commands
# ---------------

# "pd" is short for "pulumi destroy".
alias pd="pulumi destroy"

# "pp" is short for "pulumi preview".
alias pp="pulumi preview"

# "pu" is short for "pulumi up".
alias pu="pulumi up"

# "puy" is short for "pulumi up --yes".
alias puy="pulumi up --yes"

# ------------------
# Terraform Commands
# ------------------

# "ta" is short for "terraform apply".
alias ta="terraform apply"

# "taa" is short for "terraform apply -auto-approve".
alias taa="terraform apply -auto-approve"

# "tc" is short for "terraform clean".
alias tc="rm -rf .terraform .terraform.lock.hcl terraform.tfstate terraform.tfstate.backup"

# "td" is short for "terraform destroy".
alias td="terraform destroy"

# "tda" is short for "terraform destroy -auto-approve".
alias tda="terraform destroy -auto-approve"

# "tf" is short for "terraform fmt".
alias tf="terraform fmt"

# "ti" is short for "terraform init".
alias ti="terraform init"

# "tp" is short for "terraform plan".
alias tp="terraform plan"

# "tv" is short for "terraform validate".
alias tv="terraform validate"

# ------
# Prompt
# ------

# Only change the prompt if the shell is interactive.
if [[ $- == *i* ]]; then
  if ! command -v __git_ps1 &> /dev/null; then
    if [[ -f "/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh" ]]; then
      # shellcheck source=/dev/null
      source "/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh"
    else
      echo "Error: Cannot find the \"__git_ps1\" function declared." >&2
      exit
    fi
  fi

  if [ -f /etc/os-release ]; then
    # shellcheck source=/dev/null
    source /etc/os-release
  fi

  if [[ "$(uname)" == "Darwin" ]] || [[ "$ID" == "linuxmint" ]]; then
    # We copy the prompt from Git Bash for Windows:
    # https://github.com/git-for-windows/build-extra/blob/main/git-extra/git-prompt.sh
    PS1='\[\033]0;$TITLEPREFIX:$PWD\007\]' # set window title
    PS1="$PS1"'\n'                         # new line
    PS1="$PS1"'\[\033[32m\]'               # change to green
    PS1="$PS1"'\u@\h '                     # user@host<space>
    # We don't need to show the system, so the next two lines are omitted.
    PS1="$PS1"'\[\033[33m\]' # change to brownish yellow
    PS1="$PS1"'\w'           # current working directory
    GIT_EXEC_PATH="$(git --exec-path 2> /dev/null)"
    COMPLETION_PATH="${GIT_EXEC_PATH%/libexec/git-core}"
    COMPLETION_PATH="${COMPLETION_PATH%/lib/git-core}"
    COMPLETION_PATH="$COMPLETION_PATH/share/git/completion"
    PS1="$PS1"'\[\033[36m\]' # change color to cyan
    PS1="$PS1"'`__git_ps1`'  # bash function
    PS1="$PS1"'\[\033[0m\]'  # change color
    PS1="$PS1"'\n'           # new line
    PS1="$PS1"'$ '           # prompt: always $
  fi
fi
